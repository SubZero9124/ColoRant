<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="ColorRant">
    <title>ColorRant: iPad Pro</title>
    <style>
        :root { --bg: #121212; --panel: #1e1e1e; --text: #e0e0e0; --accent: #ff9f43; --blend: #4cd137; --grad: #9b59b6; --mixer: #e1b12c; }
        body { margin: 0; overflow: hidden; background: var(--bg); font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; color: var(--text); user-select: none; -webkit-user-select: none; touch-action: none; }
        
        #viewport { position: relative; width: 100vw; height: 100vh; cursor: crosshair; touch-action: none; overflow: hidden; }
        
        .layer-canvas, #overlay-canvas { 
            position: absolute; top: 0; left: 0; 
            width: 100%; height: 100%; 
            touch-action: none; 
            transform-origin: 0 0; /* Important for Zoom */
        }
        #overlay-canvas { pointer-events: none; z-index: 50; }

        .panel {
            position: absolute; background: rgba(30, 30, 30, 0.95);
            backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px); 
            padding: 12px; border-radius: 14px;
            border: 1px solid #333; display: flex; flex-direction: column; gap: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.6); pointer-events: auto;
            z-index: 60;
        }

        .top-bar { top: 20px; left: 20px; right: 20px; flex-direction: row; justify-content: space-between; align-items: center; width: auto;}
        .tools-panel { top: 90px; left: 20px; width: 260px;}
        .layers-panel { top: 90px; right: 20px; width: 200px;}

        .row { display: flex; justify-content: space-between; font-size: 11px; color: #888; font-weight: 700; margin-bottom: 4px; text-transform: uppercase; letter-spacing: 0.5px; }
        input[type="range"] { width: 100%; cursor: pointer; accent-color: var(--accent); margin: 10px 0; height: 4px; border-radius: 2px; }
        
        .rgb-box { background: #000; padding: 10px; border-radius: 8px; display: flex; flex-direction: column; gap: 6px; border: 1px solid #333; }
        .rgb-preview { width: 100%; height: 35px; border-radius: 4px; border: 1px solid #555; margin-bottom: 5px; }
        .rgb-row { display: flex; align-items: center; gap: 8px; font-size: 11px; font-weight: bold; }
        
        .btn-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .btn { background: #2c2c2c; border: 1px solid #3a3a3a; color: #aaa; padding: 14px 8px; font-size: 12px; text-align: center; border-radius: 8px; transition: 0.2s; }
        .btn:active { background: #444; }
        .btn.active { background: var(--accent); color: #111; border-color: var(--accent); font-weight: 800; }
        
        .tool-group { display: flex; gap: 4px; background: #000; padding: 6px; border-radius: 10px; }
        .t-btn { flex: 1; padding: 12px 2px; text-align: center; font-size: 12px; color: #777; font-weight: bold; border-radius: 6px; }
        .t-btn.active { background: #333; color: #fff; }
        .t-btn.mixer-active { background: var(--mixer); color: #000; }
        .t-btn.blend-active { background: var(--blend); color: #000; }
        .t-btn.grad-active { background: var(--grad); color: #fff; }
        
        .layer-list { height: 200px; overflow-y: auto; background: #000; border: 1px solid #333; padding: 4px; display: flex; flex-direction: column-reverse; gap: 2px; border-radius: 6px;}
        .l-item { padding: 14px 10px; background: #222; font-size: 13px; display: flex; justify-content: space-between; align-items: center; border-radius: 4px; margin-bottom: 2px;}
        .l-item.active { background: #333; border-left: 4px solid var(--accent); color: #fff; }
        .l-vis { width: 12px; height: 12px; border-radius: 50%; background: #444; }
        .l-vis.on { background: var(--accent); }
        
        .layer-controls { border-top: 1px solid #333; padding-top: 12px; margin-top: 8px; }
        .lc-row { display: flex; justify-content: space-between; align-items: center; font-size: 12px; margin-bottom: 10px; color: #aaa; }
        select { background: #111; border: 1px solid #333; color: #ccc; font-size: 13px; width: 90px; padding: 6px; border-radius: 6px;}
        .chk-label { display: flex; align-items: center; gap: 8px; }
        input[type="checkbox"] { transform: scale(1.3); accent-color: var(--accent); }

        .grad-row { display: flex; gap: 8px; }
        .grad-input { flex: 1; height: 35px; border:none; background:none; }

        #cursor { position: absolute; pointer-events: none; border: 1px solid rgba(255,255,255,0.8); transform: translate(-50%, -50%); z-index: 200; mix-blend-mode: exclusion; }
        
        #sample-feedback {
            position: absolute; width: 60px; height: 60px; border: 4px solid var(--mixer);
            border-radius: 50%; pointer-events: none; transform: translate(-50%, -50%) scale(0);
            transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275); z-index: 201; box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        #sample-feedback.active { transform: translate(-50%, -50%) scale(1); }
    </style>
</head>
<body>

<div id="viewport">
    <div id="layer-container"></div>
    <canvas id="overlay-canvas"></canvas>
    <div id="sample-feedback"></div>

    <div class="panel top-bar">
        <div style="font-weight:900; color:var(--accent); letter-spacing:1px; font-size:18px;">ColorRant</div>
        <div class="tool-group">
            <div id="t-paint" class="t-btn active" onclick="setTool('brush')">PAINT</div>
            <div id="t-mixer" class="t-btn" onclick="setTool('mixer')">MIX</div>
            <div id="t-blend" class="t-btn" onclick="setTool('blend')">BLEND</div>
            <div id="t-grad" class="t-btn" onclick="setTool('gradient')">GRAD</div>
            <div id="t-lasso" class="t-btn" onclick="setTool('lasso')">SEL</div>
            <div id="t-erase" class="t-btn" onclick="setTool('eraser')">ERS</div>
        </div>
        <div class="tool-group" style="margin-left:5px;">
            <div class="t-btn" onclick="undo()" style="font-size:16px;">↶</div>
            <div class="t-btn" onclick="redo()" style="font-size:16px;">↷</div>
        </div>
    </div>

    <div class="panel tools-panel">
        <div class="rgb-box">
            <div id="rgbPreview" class="rgb-preview" style="background: #ff9f43;"></div>
            <div class="rgb-row"><span style="color:#ff4757">R</span><input type="range" id="sl-r" min="0" max="255" value="255"></div>
            <div class="rgb-row"><span style="color:#2ecc71">G</span><input type="range" id="sl-g" min="0" max="255" value="159"></div>
            <div class="rgb-row"><span style="color:#3498db">B</span><input type="range" id="sl-b" min="0" max="255" value="67"></div>
        </div>
        
        <div id="brush-controls">
            <div class="row">Brush Engine</div>
            <div class="btn-grid" style="grid-template-columns: 1fr 1fr 1fr;">
                <div class="btn" onclick="setBrush('block')">BLK</div>
                <div class="btn" onclick="setBrush('round')">RND</div>
                <div class="btn active" onclick="setBrush('rake')">RAKE</div>
                <div class="btn" onclick="setBrush('air_soft')">SOFT</div>
                <div class="btn" onclick="setBrush('air_grain')">GRAIN</div>
            </div>
            <div style="margin-top:5px;">
                <div class="row"><span>Size</span> <span id="val-size">60</span></div>
                <input type="range" id="sl-size" min="5" max="300" value="60">
            </div>
            <div style="background:rgba(76, 209, 55, 0.1); padding:6px; border-radius:4px; border:1px solid rgba(76, 209, 55, 0.3);">
                <div class="row" style="color:var(--blend);"><span>Blend</span> <span id="val-mix">20</span></div>
                <input type="range" id="sl-mix" min="1" max="100" value="20">
            </div>
            <div>
                <div class="row"><span>Jitter</span> <span id="val-jitter">0</span></div>
                <input type="range" id="sl-jitter" min="0" max="100" value="0">
            </div>
            <div style="margin-top:8px; border-top:1px solid #333; padding-top:5px;">
                <div class="lc-row"><label class="chk-label"><input type="checkbox" id="pressureChk" checked onchange="state.usePressure = this.checked"> Pressure Sensitivity</label></div>
            </div>
            <div id="mixer-hint" style="display:none; font-size:11px; color:#e1b12c; margin-top:5px; border:1px solid #e1b12c; padding:6px; border-radius:4px; background:rgba(225, 177, 44, 0.1);">Mixer: Hold Pencil still to sample.</div>
        </div>

        <div id="grad-controls" style="display:none;">
            <div class="row" style="color:var(--grad);">Gradient</div>
            <div class="grad-row"><input type="color" id="gradStart" class="grad-input" value="#ff9f43"><input type="color" id="gradEnd" class="grad-input" value="#2c3e50"></div>
            <div class="row" style="margin-top:8px;">Opacity</div>
            <div class="grad-row"><input type="range" id="gradStartAlpha" min="0" max="100" value="100"><input type="range" id="gradEndAlpha" min="0" max="100" value="100"></div>
        </div>

        <div id="lasso-controls" style="display:none;">
            <div class="row" style="color:#00a8ff;">Selection</div>
            <div class="btn-grid" style="grid-template-columns: 1fr 1fr;">
                <div class="btn active" onclick="setLassoMode('free')">FREE</div>
                <div class="btn" onclick="setLassoMode('poly')">POLY</div>
                <div class="btn" onclick="setLassoMode('rect')">RECT</div>
                <div class="btn" onclick="setLassoMode('circ')">CIRC</div>
            </div>
            <div style="font-size:11px; color:#888; margin-top:5px;">Selections <b>ADD</b>. Tap "SEL" to Deselect.</div>
        </div>
        
        <div style="margin-top: 15px; border-top: 1px solid #333; padding-top: 10px;">
            <div class="btn" style="background: #2980b9; color: white;" onclick="saveImage()">SAVE PNG</div>
        </div>
    </div>

    <div class="panel layers-panel">
        <div class="row">Layers</div>
        <div class="layer-list" id="layerList"></div>
        <div class="layer-controls">
            <div class="lc-row">
                <span>Mode</span>
                <select id="blendModeSel" onchange="setLayerProp('blendMode', this.value)">
                    <option value="normal">Normal</option>
                    <option value="multiply">Multiply</option>
                    <option value="color-dodge">Dodge</option>
                    <option value="overlay">Overlay</option>
                </select>
            </div>
            <div class="lc-row"><label class="chk-label"><input type="checkbox" id="alphaLockChk" onchange="setLayerProp('alphaLock', this.checked)"> Alpha Lock</label></div>
            <div class="lc-row"><label class="chk-label"><input type="checkbox" id="clipMaskChk" onchange="setLayerProp('clipped', this.checked)"> Clip Mask</label></div>
        </div>
        <div class="btn-grid" style="margin-top: 10px;">
            <div class="btn" onclick="addLayer()">NEW</div>
            <div class="btn" style="color:#ff7675" onclick="deleteLayer()">DEL</div>
            <div class="btn" onclick="clearLayer()">CLR</div>
        </div>
    </div>
</div>

<div id="cursor"></div>

<script>
    const CONFIG = { w: window.innerWidth, h: window.innerHeight };
    const state = {
        tool: 'brush', lastTool: null, brush: 'rake', color: '#ff9f43', size: 60, mix: 0.20, jitter: 0,
        isDrawing: false, canBlend: false, isSampling: false, mixerBuffer: null,
        lassoPoly: [], lassoMode: 'free', lassoStart: null, selectionPath: null, dashOffset: 0,
        gradStartColor: '#ff9f43', gradEndColor: '#2c3e50', gradStartOpacity: 1.0, gradEndOpacity: 1.0,
        gradDragStart: null, gradDragCurrent: null, pressure: 1.0, usePressure: true
    };

    // --- ZOOM & PAN STATE ---
    const view = { x: 0, y: 0, scale: 1.0 };
    let lastDist = 0;
    let lastCenter = null;

    let bristles = [], brushLoad = {r:0, g:0, b:0}; const BRISTLE_COUNT = 15;
    let layers = [], activeIdx = 0, layerCounter = 0;
    const MAX_HISTORY = 10; let historyStack = [], redoStack = [];
    let dragItem = null, dragOffset = {x:0, y:0};
    
    let longPressTimer = null;
    let longPressOrigin = null;

    const overlayCtx = document.getElementById('overlay-canvas').getContext('2d');
    const cursor = document.getElementById('cursor');
    const viewport = document.getElementById('viewport');
    const layerContainer = document.getElementById('layer-container');
    const overlayCanvasEl = document.getElementById('overlay-canvas');
    const scratchCanvas = document.createElement('canvas');
    const scratchCtx = scratchCanvas.getContext('2d');

    function getGradientColor(hex, alpha) {
        const rgb = hexToRgb(hex);
        return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`;
    }

    function getPos(e) { 
        const r = viewport.getBoundingClientRect(); 
        // Convert Screen Coordinates -> Zoomed Canvas Coordinates
        return { 
            x: (e.clientX - r.left - view.x) / view.scale, 
            y: (e.clientY - r.top - view.y) / view.scale 
        }; 
    }

    function updateView() {
        const transform = `translate(${view.x}px, ${view.y}px) scale(${view.scale})`;
        layerContainer.style.transform = transform;
        layerContainer.style.transformOrigin = '0 0';
        overlayCanvasEl.style.transform = transform;
        overlayCanvasEl.style.transformOrigin = '0 0';
        updateCursorUI(null); 
    }

    window.onload = function() {
        resize();
        window.addEventListener('resize', resize);
        addLayer();
        requestAnimationFrame(animLoop);
        updateUI();
    };

    // --- TOUCH GESTURES (ZOOM/PAN) ---
    window.addEventListener('touchstart', e => {
        if (e.touches.length === 2) {
            state.isDrawing = false; 
            const p1 = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            const p2 = { x: e.touches[1].clientX, y: e.touches[1].clientY };
            lastDist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
            lastCenter = { x: (p1.x + p2.x)/2, y: (p1.y + p2.y)/2 };
        }
    }, {passive: false});

    window.addEventListener('touchmove', e => {
        if (e.touches.length === 2) {
            e.preventDefault(); 
            const p1 = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            const p2 = { x: e.touches[1].clientX, y: e.touches[1].clientY };
            
            const dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
            const center = { x: (p1.x + p2.x)/2, y: (p1.y + p2.y)/2 };

            if (lastDist && lastCenter) {
                // Pan
                const dx = center.x - lastCenter.x;
                const dy = center.y - lastCenter.y;
                view.x += dx;
                view.y += dy;

                // Zoom
                const zoomFactor = dist / lastDist;
                const newScale = Math.min(Math.max(view.scale * zoomFactor, 0.5), 5.0); 
                
                // Zoom towards center
                const scaleRatio = newScale / view.scale;
                view.x = center.x - (center.x - view.x) * scaleRatio;
                view.y = center.y - (center.y - view.y) * scaleRatio;
                view.scale = newScale;

                updateView();
            }

            lastDist = dist;
            lastCenter = center;
        }
    }, {passive: false});

    window.addEventListener('touchend', e => {
        if (e.touches.length < 2) {
            lastDist = 0;
            lastCenter = null;
        }
    });

    function animLoop() {
        overlayCtx.clearRect(0, 0, CONFIG.w, CONFIG.h);

        if (state.selectionPath) {
            state.dashOffset++;
            if (state.dashOffset > 16) state.dashOffset = 0;
            
            overlayCtx.save();
            overlayCtx.strokeStyle = 'white';
            overlayCtx.lineWidth = 1 / view.scale; 
            overlayCtx.setLineDash([5, 5]);
            overlayCtx.lineDashOffset = -state.dashOffset;
            overlayCtx.stroke(state.selectionPath);
            
            overlayCtx.strokeStyle = 'black';
            overlayCtx.lineDashOffset = -state.dashOffset + 5;
            overlayCtx.stroke(state.selectionPath);
            overlayCtx.restore();
        }

        if (state.tool === 'lasso' && state.lassoPoly.length > 0) {
            overlayCtx.save();
            overlayCtx.strokeStyle = '#00a8ff';
            overlayCtx.lineWidth = 1 / view.scale;
            overlayCtx.beginPath();
            
            if (state.lassoMode === 'rect' && state.lassoPoly.length >= 1 && state.gradDragCurrent) {
                const s = state.lassoPoly[0];
                const c = state.gradDragCurrent;
                overlayCtx.rect(s.x, s.y, c.x - s.x, c.y - s.y);
            } else if (state.lassoMode === 'poly' || state.lassoMode === 'free') {
                overlayCtx.moveTo(state.lassoPoly[0].x, state.lassoPoly[0].y);
                for(let i=1; i<state.lassoPoly.length; i++) {
                    overlayCtx.lineTo(state.lassoPoly[i].x, state.lassoPoly[i].y);
                }
                if (state.lassoMode === 'poly' && state.gradDragCurrent) {
                    overlayCtx.lineTo(state.gradDragCurrent.x, state.gradDragCurrent.y);
                }
            } else if (state.lassoMode === 'circ' && state.lassoPoly.length >= 1 && state.gradDragCurrent) {
                const s = state.lassoPoly[0];
                const c = state.gradDragCurrent;
                const r = Math.hypot(c.x - s.x, c.y - s.y);
                overlayCtx.arc(s.x, s.y, r, 0, Math.PI*2);
            }
            overlayCtx.stroke();
            overlayCtx.restore();
        }

        if (state.tool === 'gradient' && state.gradDragStart && state.gradDragCurrent) {
            overlayCtx.save();
            overlayCtx.beginPath();
            overlayCtx.moveTo(state.gradDragStart.x, state.gradDragStart.y);
            overlayCtx.lineTo(state.gradDragCurrent.x, state.gradDragCurrent.y);
            overlayCtx.strokeStyle = 'white';
            overlayCtx.lineWidth = 2 / view.scale;
            overlayCtx.shadowColor = 'black';
            overlayCtx.shadowBlur = 4;
            overlayCtx.stroke();
            
            overlayCtx.fillStyle = state.gradStartColor;
            overlayCtx.beginPath(); overlayCtx.arc(state.gradDragStart.x, state.gradDragStart.y, 5 / view.scale, 0, Math.PI*2); overlayCtx.fill();
            overlayCtx.fillStyle = state.gradEndColor;
            overlayCtx.beginPath(); overlayCtx.arc(state.gradDragCurrent.x, state.gradDragCurrent.y, 5 / view.scale, 0, Math.PI*2); overlayCtx.fill();
            overlayCtx.restore();
        }

        requestAnimationFrame(animLoop);
    }

    function resize() {
        CONFIG.w = window.innerWidth; 
        CONFIG.h = window.innerHeight;
        const dpr = window.devicePixelRatio || 1;
        
        document.getElementById('overlay-canvas').width = CONFIG.w * dpr;
        document.getElementById('overlay-canvas').height = CONFIG.h * dpr;
        document.getElementById('overlay-canvas').style.width = CONFIG.w + 'px';
        document.getElementById('overlay-canvas').style.height = CONFIG.h + 'px';
        overlayCtx.setTransform(1, 0, 0, 1, 0, 0); 
        overlayCtx.scale(dpr, dpr);

        layers.forEach(l => {
            const t = document.createElement('canvas'); 
            t.width = l.canvas.width; t.height = l.canvas.height;
            t.getContext('2d').drawImage(l.canvas, 0, 0);
            
            l.canvas.width = CONFIG.w * dpr; 
            l.canvas.height = CONFIG.h * dpr;
            l.canvas.style.width = CONFIG.w + 'px';
            l.canvas.style.height = CONFIG.h + 'px';
            l.ctx.setTransform(1, 0, 0, 1, 0, 0);
            l.ctx.scale(dpr, dpr);
            l.ctx.drawImage(t, 0, 0, t.width, t.height, 0, 0, CONFIG.w, CONFIG.h);
        });
    }

    function handlePointerDown(e) {
        if (e.target.closest('button, input, select, label, .btn, .t-btn, .l-item')) return;
        if(e.pointerType === 'touch') return; 

        const panel = e.target.closest('.panel');
        if (panel) {
            dragItem = panel; const r = panel.getBoundingClientRect();
            panel.style.right = 'auto'; panel.style.left = r.left+'px'; panel.style.top = r.top+'px';
            dragOffset = {x: e.clientX - r.left, y: e.clientY - r.top}; return;
        }

        const p = getPos(e); lastPos = p;
        if(e.pressure!==undefined && e.pointerType==='pen') state.pressure=e.pressure; else state.pressure=1.0;

        if(state.tool === 'mixer') {
            longPressOrigin = {x: e.clientX, y: e.clientY}; 
            longPressTimer = setTimeout(() => {
                sampleMixer(p.x, p.y); 
                longPressTimer = null;
                const fb = document.getElementById('sample-feedback');
                fb.style.left = e.clientX+'px'; fb.style.top = e.clientY+'px';
                fb.classList.add('active');
                setTimeout(() => fb.classList.remove('active'), 300);
            }, 500); 
            return; 
        }
        startStroke(p);
    }

    function startStroke(p) {
        state.isDrawing = true;
        state.canBlend = true;
        if (state.tool === 'blend') { if (!pickColorAt(layers[activeIdx].ctx, p.x, p.y)) state.canBlend = false; }

        if(state.tool === 'lasso') {
            if(state.lassoMode==='poly' || state.lassoMode==='free') state.lassoPoly.push(p);
            else { state.lassoStart = p; state.lassoPoly = [p]; }
        } else if(state.tool === 'gradient') { state.gradDragStart = p; state.gradDragCurrent = p; }
        else if(state.tool === 'picker') { pickColorUI(p); }
        else {
            saveHistory(); initPhysics(hexToRgb(state.color)); draw(p, p);
        }
    }

    function handlePointerMove(e) {
        if(e.pointerType === 'touch') return;
        if(dragItem) { dragItem.style.left = (e.clientX - dragOffset.x)+'px'; dragItem.style.top = (e.clientY - dragOffset.y)+'px'; return; }
        
        updateCursorUI({x: e.clientX, y: e.clientY}, e.altKey);
        
        const p = getPos(e); 
        if(e.pressure!==undefined && e.pointerType==='pen') state.pressure=e.pressure;
        
        state.gradDragCurrent = p; 

        if (state.tool === 'mixer' && longPressTimer) {
            const d = Math.hypot(e.clientX - longPressOrigin.x, e.clientY - longPressOrigin.y);
            if (d > 5) { clearTimeout(longPressTimer); longPressTimer = null; startStroke(lastPos); }
        }

        if(!state.isDrawing && state.lassoMode !== 'poly') return;
        
        if(state.tool === 'lasso') {
            if(state.lassoMode==='free') state.lassoPoly.push(p); 
            else if(state.lassoMode!=='poly') state.lassoPoly = [state.lassoStart, p];
        } 
        else if(state.tool === 'picker') pickColorUI(p);
        else if(state.isDrawing && state.tool !== 'gradient' && state.tool !== 'lasso') { draw(lastPos, p); lastPos = p; }
    }

    function handlePointerUp(e) {
        if(e.pointerType === 'touch') return;
        if(dragItem) { dragItem = null; return; }
        if (longPressTimer) { clearTimeout(longPressTimer); longPressTimer = null; }

        if(state.tool === 'lasso' && state.lassoMode !== 'poly') { finishLasso(); state.isDrawing = false; }
        else if(state.tool === 'gradient' && state.isDrawing) { saveHistory(); applyGradient(); state.isDrawing = false; }
        else if(state.tool !== 'lasso') state.isDrawing = false;
        
        state.gradDragStart = null; 
    }

    let lastTapTime = 0;
    window.addEventListener('touchstart', e => {
        if(e.touches.length === 2 || e.touches.length === 3) {
            const now = Date.now();
            if(now - lastTapTime < 400) {
                e.preventDefault();
                if(e.touches.length === 2) undo();
                if(e.touches.length === 3) redo();
                lastTapTime = 0;
            } else lastTapTime = now;
        }
    }, {passive: false});

    window.addEventListener('pointerdown', handlePointerDown);
    window.addEventListener('pointermove', handlePointerMove);
    window.addEventListener('pointerup', handlePointerUp);
    window.addEventListener('dblclick', () => { if(state.tool === 'lasso' && state.lassoMode === 'poly') finishLasso(); });

    function draw(p1, p2) {
        if (!layers[activeIdx]) return;
        const ctx = layers[activeIdx].ctx;
        if (state.tool === 'blend' && !state.canBlend) return;

        const dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
        const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
        
        let stepSize = state.size / 8;
        if(state.brush === 'rake') stepSize = state.size / 15;
        if(state.brush === 'air_soft') stepSize = state.size / 10;

        const steps = Math.ceil(dist / Math.max(1, stepSize));

        ctx.save();
        if(state.selectionPath) ctx.clip(state.selectionPath);

        if (state.tool === 'eraser') ctx.globalCompositeOperation = 'destination-out';
        else if (layers[activeIdx].alphaLock) ctx.globalCompositeOperation = 'source-atop';
        else ctx.globalCompositeOperation = 'source-over';

        const isClipped = layers[activeIdx].clipped && activeIdx > 0 && state.tool !== 'eraser';
        let currentSize = state.size;
        if (state.usePressure) currentSize = Math.max(1, state.size * state.pressure);

        for(let i=0; i<=steps; i++) {
            const t = steps===0 ? 0 : i/steps;
            const x = lerp(p1.x, p2.x, t);
            const y = lerp(p1.y, p2.y, t);

            if (isClipped && (state.brush === 'round' || state.brush === 'block' || state.brush === 'air_soft' || state.tool === 'mixer')) {
                const dpr = window.devicePixelRatio || 1;
                scratchCanvas.width = currentSize * 2 * dpr; 
                scratchCanvas.height = currentSize * 2 * dpr;
                scratchCtx.setTransform(1, 0, 0, 1, 0, 0); 
                scratchCtx.scale(dpr, dpr); 
                scratchCtx.clearRect(0, 0, currentSize * 2, currentSize * 2);
                
                scratchCtx.save();
                scratchCtx.translate(currentSize, currentSize);
                if(state.brush !== 'round' && state.brush !== 'air_soft') scratchCtx.rotate(angle);

                if (state.tool === 'mixer' && state.mixerBuffer) {
                    scratchCtx.beginPath();
                    if(state.brush==='block') scratchCtx.rect(-currentSize/2, -currentSize/2, currentSize, currentSize);
                    else scratchCtx.arc(0, 0, currentSize/2, 0, Math.PI*2);
                    scratchCtx.clip();
                    scratchCtx.drawImage(state.mixerBuffer, -currentSize/2, -currentSize/2, currentSize, currentSize);
                } else {
                    prepBrushColor(ctx, x, y); const c = brushLoad;
                    scratchCtx.fillStyle = `rgb(${c.r|0},${c.g|0},${c.b|0})`;
                    if (state.tool === 'blend') scratchCtx.globalAlpha = 0.4;
                    if(state.brush === 'block') scratchCtx.fillRect(-currentSize/2, -currentSize/2, currentSize, currentSize);
                    else if(state.brush === 'round') { scratchCtx.beginPath(); scratchCtx.arc(0,0, currentSize/2, 0, Math.PI*2); scratchCtx.fill(); }
                    else if(state.brush === 'air_soft') {
                        const g = scratchCtx.createRadialGradient(0,0,0, 0,0,currentSize/2);
                        const alpha = state.tool === 'blend' ? 0.2 : 0.1; 
                        g.addColorStop(0, `rgba(${c.r|0},${c.g|0},${c.b|0},${alpha})`);
                        g.addColorStop(1, `rgba(${c.r|0},${c.g|0},${c.b|0},0)`);
                        scratchCtx.fillStyle = g;
                        scratchCtx.fillRect(-currentSize/2, -currentSize/2, currentSize, currentSize);
                    }
                }
                scratchCtx.restore();
                scratchCtx.globalCompositeOperation = 'destination-in';
                scratchCtx.drawImage(layers[activeIdx-1].canvas, (x - currentSize)*dpr, (y - currentSize)*dpr, currentSize*2*dpr, currentSize*2*dpr, 0, 0, currentSize*2, currentSize*2);
                ctx.drawImage(scratchCanvas, 0, 0, currentSize*2*dpr, currentSize*2*dpr, x - currentSize, y - currentSize, currentSize*2, currentSize*2);
                continue;
            }

            if (state.tool === 'mixer' && state.mixerBuffer) {
                ctx.save(); ctx.translate(x, y); if (state.brush === 'rake') ctx.rotate(angle);
                ctx.beginPath();
                if (state.brush === 'block') ctx.rect(-currentSize/2, -currentSize/2, currentSize, currentSize);
                else if (state.brush === 'rake') {
                    const bristleH = currentSize / BRISTLE_COUNT;
                    for(let b=0; b<BRISTLE_COUNT; b++) ctx.rect(-currentSize/2, -currentSize/2 + (b * bristleH), currentSize, bristleH-1);
                } else ctx.arc(0, 0, currentSize/2, 0, Math.PI*2);
                ctx.clip();
                ctx.drawImage(state.mixerBuffer, -currentSize/2, -currentSize/2, currentSize, currentSize);
                ctx.restore();
                continue; 
            }

            const isVisible = (tx, ty) => {
                if (!isClipped) return true;
                const dpr = window.devicePixelRatio || 1;
                const pixel = layers[activeIdx-1].ctx.getImageData(tx*dpr, ty*dpr, 1, 1).data;
                return pixel[3] > 10;
            };

            if(state.brush === 'rake') {
                ctx.save(); ctx.translate(x, y); ctx.rotate(angle);
                const bristleH = currentSize / BRISTLE_COUNT;
                const startY = -currentSize/2;
                for(let b=0; b<BRISTLE_COUNT; b++) {
                    const bristle = bristles[b];
                    const localY = startY + (b * bristleH) + bristle.offset;
                    const h = bristleH * bristle.thickness;
                    const gx = x - Math.sin(angle) * localY, gy = y + Math.cos(angle) * localY;
                    if (!isVisible(gx, gy)) continue;
                    if(state.tool === 'blend') {
                        const bg = pickColorAt(ctx, gx, gy); 
                        if(bg) { bristles[b].r = lerp(bristles[b].r, bg.r, state.mix); bristles[b].g = lerp(bristles[b].g, bg.g, state.mix); bristles[b].b = lerp(bristles[b].b, bg.b, state.mix); }
                    }
                    ctx.fillStyle = `rgb(${bristles[b].r|0}, ${bristles[b].g|0}, ${bristles[b].b|0})`;
                    ctx.fillRect(-currentSize/10, localY, currentSize/5, h); 
                }
                ctx.restore();
            } else if (state.brush === 'air_grain') {
                prepBrushColor(ctx, x, y); const c = brushLoad;
                ctx.fillStyle = `rgb(${c.r|0},${c.g|0},${c.b|0})`;
                for(let k=0; k<80; k++) {
                    const rx = (Math.random()+Math.random()+Math.random()-1.5)/1.5 * (currentSize/2);
                    const ry = (Math.random()+Math.random()+Math.random()-1.5)/1.5 * (currentSize/2);
                    if (isVisible(x + rx, y + ry)) {
                       if(rx*rx+ry*ry < (currentSize/2)**2) ctx.fillRect(x+rx, y+ry, 1.5, 1.5);
                    }
                }
            } else {
                prepBrushColor(ctx, x, y); const c = brushLoad;
                if(state.tool === 'blend' && (state.brush === 'block' || state.brush === 'round')) ctx.globalAlpha = 0.4;
                else ctx.globalAlpha = 1.0;

                if(state.brush === 'block') {
                    ctx.fillStyle = `rgb(${c.r|0},${c.g|0},${c.b|0})`;
                    ctx.save(); ctx.translate(x,y); ctx.rotate(angle);
                    ctx.fillRect(-currentSize/2, -currentSize/2, currentSize, currentSize);
                    ctx.restore();
                } else if(state.brush === 'round') {
                    ctx.fillStyle = `rgb(${c.r|0},${c.g|0},${c.b|0})`;
                    ctx.beginPath(); ctx.arc(x,y, currentSize/2, 0, Math.PI*2); ctx.fill();
                } else if(state.brush === 'air_soft') {
                    const g = ctx.createRadialGradient(x,y,0, x,y,currentSize/2);
                    const alpha = state.tool === 'blend' ? 0.2 : 0.1; 
                    g.addColorStop(0, `rgba(${c.r|0},${c.g|0},${c.b|0},${alpha})`);
                    g.addColorStop(1, `rgba(${c.r|0},${c.g|0},${c.b|0},0)`);
                    ctx.fillStyle = g;
                    ctx.fillRect(x-currentSize/2, y-currentSize/2, currentSize, currentSize);
                }
            }
        }
        ctx.restore();
    }

    function prepBrushColor(ctx, x, y) {
        if(state.tool === 'blend') {
            const bg = pickColorAt(ctx, x, y);
            if(bg) { brushLoad.r = lerp(brushLoad.r, bg.r, state.mix); brushLoad.g = lerp(brushLoad.g, bg.g, state.mix); brushLoad.b = lerp(brushLoad.b, bg.b, state.mix); }
        } else if(state.jitter > 0) brushLoad = getJitteredColor(hexToRgb(state.color), state.jitter);
        else { const rgb = hexToRgb(state.color); brushLoad = {r:rgb.r, g:rgb.g, b:rgb.b}; }
    }

    function hexToRgb(hex) { const v = parseInt(hex.slice(1), 16); return { r: (v >> 16) & 255, g: (v >> 8) & 255, b: v & 255 }; }
    function lerp(a, b, t) { return a + (b - a) * t; }
    function pickColorAt(ctx, x, y) { 
        const dpr = window.devicePixelRatio || 1;
        const p = ctx.getImageData(x*dpr, y*dpr, 1, 1).data; 
        return p[3] < 10 ? null : { r: p[0], g: p[1], b: p[2] }; 
    }
    function sampleMixer(x, y) { 
        const dpr = window.devicePixelRatio || 1;
        const s = state.size; const data = layers[activeIdx].ctx.getImageData((x - s/2)*dpr, (y - s/2)*dpr, s*dpr, s*dpr); 
        const c = document.createElement('canvas'); c.width = s; c.height = s; 
        const t = c.getContext('2d');
        const temp = document.createElement('canvas'); temp.width = s*dpr; temp.height = s*dpr;
        temp.getContext('2d').putImageData(data, 0, 0);
        t.drawImage(temp, 0, 0, s*dpr, s*dpr, 0, 0, s, s);
        state.mixerBuffer = c; 
    }

    function getJitteredColor(base, amount) {
        if (amount <= 0) return base;
        let r = base.r/255, g = base.g/255, b = base.b/255;
        let max = Math.max(r, g, b), min = Math.min(r, g, b), h, s, l = (max + min) / 2;
        if(max !== min) {
            let d = max - min; s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) { case r: h = (g - b) / d + (g < b ? 6 : 0); break; case g: h = (b - r) / d + 2; break; case b: h = (r - g) / d + 4; break; }
            h /= 6;
        }
        h = (h + (Math.random()-0.5)*(amount/200) + 1) % 1;
        s = Math.max(0, Math.min(1, s + (Math.random()-0.2)*(amount/200)));
        l = Math.max(0, Math.min(1, l + (Math.random()-0.5)*(amount/150)));
        let r1, g1, b1;
        if (s === 0) r1 = g1 = b1 = l; else {
            const hue2rgb = (p, q, t) => { if (t < 0) t += 1; if (t > 1) t -= 1; if (t < 1/6) return p + (q - p) * 6 * t; if (t < 1/2) return q; if (t < 2/3) return p + (q - p) * (2/3 - t) * 6; return p; }
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s; const p = 2 * l - q;
            r1 = hue2rgb(p, q, h + 1/3); g1 = hue2rgb(p, q, h); b1 = hue2rgb(p, q, h - 1/3);
        }
        return { r: r1 * 255, g: g1 * 255, b: b1 * 255 };
    }

    function initPhysics(startColor) {
        bristles = [];
        for(let i=0; i<BRISTLE_COUNT; i++) {
            const c = (state.tool === 'brush') ? getJitteredColor(startColor, state.jitter) : startColor;
            bristles.push({ r: c.r, g: c.g, b: c.b, thickness: 0.5 + Math.random(), offset: (Math.random() - 0.5) * (state.size / BRISTLE_COUNT) * 0.8 });
        }
        const c = (state.tool === 'brush') ? getJitteredColor(startColor, state.jitter) : startColor;
        brushLoad = { r: c.r, g: c.g, b: c.b };
    }

    function applyGradient() {
        if(!state.gradDragStart || !state.gradDragCurrent) return;
        const ctx = layers[activeIdx].ctx;
        ctx.save();
        if(state.selectionPath) ctx.clip(state.selectionPath);
        
        const dpr = window.devicePixelRatio || 1;
        if (layers[activeIdx].clipped && activeIdx > 0) {
            const temp = document.createElement('canvas'); 
            temp.width = CONFIG.w * dpr; temp.height = CONFIG.h * dpr; 
            const tCtx = temp.getContext('2d');
            tCtx.scale(dpr, dpr);
            
            const p1 = state.gradDragStart, p2 = state.gradDragCurrent;
            const grad = tCtx.createLinearGradient(p1.x, p1.y, p2.x, p2.y);
            grad.addColorStop(0, getGradientColor(state.gradStartColor, state.gradStartOpacity));
            grad.addColorStop(1, getGradientColor(state.gradEndColor, state.gradEndOpacity));
            tCtx.fillStyle = grad; tCtx.fillRect(0, 0, CONFIG.w, CONFIG.h);
            
            tCtx.globalCompositeOperation = 'destination-in'; 
            tCtx.drawImage(layers[activeIdx-1].canvas, 0, 0, CONFIG.w * dpr, CONFIG.h * dpr, 0, 0, CONFIG.w, CONFIG.h);
            
            ctx.drawImage(temp, 0, 0, CONFIG.w * dpr, CONFIG.h * dpr, 0, 0, CONFIG.w, CONFIG.h);
        } else {
            if (layers[activeIdx].alphaLock) ctx.globalCompositeOperation = 'source-atop';
            const p1 = state.gradDragStart, p2 = state.gradDragCurrent;
            const grad = ctx.createLinearGradient(p1.x, p1.y, p2.x, p2.y);
            grad.addColorStop(0, getGradientColor(state.gradStartColor, state.gradStartOpacity));
            grad.addColorStop(1, getGradientColor(state.gradEndColor, state.gradEndOpacity));
            ctx.fillStyle = grad; ctx.fillRect(0, 0, CONFIG.w, CONFIG.h);
        }
        ctx.restore();
    }

    function finishLasso() {
        if(state.lassoPoly.length < 2 && state.lassoMode !== 'poly') return; 
        const p = new Path2D();
        if (state.lassoMode === 'rect') { const s = state.lassoPoly[0], e = state.lassoPoly[1]; if(s&&e) p.rect(s.x, s.y, e.x - s.x, e.y - s.y); } 
        else if (state.lassoMode === 'circ') { const s = state.lassoPoly[0], e = state.lassoPoly[1]; if(s&&e) p.arc(s.x, s.y, Math.hypot(e.x - s.x, e.y - s.y), 0, Math.PI*2); } 
        else { if(state.lassoPoly.length > 0) { p.moveTo(state.lassoPoly[0].x, state.lassoPoly[0].y); state.lassoPoly.forEach(pt => p.lineTo(pt.x, pt.y)); p.closePath(); } }
        if (state.selectionPath) state.selectionPath.addPath(p); else state.selectionPath = p;
        state.lassoPoly = [];
    }

    function updateColorFromSliders() {
        const r = parseInt(document.getElementById('sl-r').value), g = parseInt(document.getElementById('sl-g').value), b = parseInt(document.getElementById('sl-b').value);
        state.color = "#" + [r,g,b].map(x=>x.toString(16).padStart(2,'0')).join('');
        document.getElementById('rgbPreview').style.background = state.color;
    }
    function updateSlidersFromColor(hex) {
        const rgb = hexToRgb(hex); document.getElementById('sl-r').value = rgb.r; document.getElementById('sl-g').value = rgb.g; document.getElementById('sl-b').value = rgb.b;
        document.getElementById('rgbPreview').style.background = hex;
    }
    function addLayer() {
        const c = document.createElement('canvas'); c.width = CONFIG.w; c.height = CONFIG.h; c.className = 'layer-canvas';
        document.getElementById('layer-container').appendChild(c);
        const dpr = window.devicePixelRatio || 1;
        c.width = CONFIG.w * dpr; c.height = CONFIG.h * dpr;
        c.style.width = CONFIG.w + 'px'; c.style.height = CONFIG.h + 'px';
        const ctx = c.getContext('2d', { willReadFrequently: true });
        ctx.scale(dpr, dpr);
        
        layers.push({ id: layerCounter++, canvas: c, ctx: ctx, visible: true, name: `Layer ${layerCounter}`, blendMode: 'normal', alphaLock: false, clipped: false });
        setActiveLayer(layers.length - 1);
    }
    function setActiveLayer(idx) { if(idx < 0 || idx >= layers.length) return; activeIdx = idx; renderLayerUI(); updateLayerControls(); }
    function updateLayerControls() {
        const l = layers[activeIdx];
        document.getElementById('blendModeSel').value = l.blendMode;
        document.getElementById('alphaLockChk').checked = l.alphaLock;
        document.getElementById('clipMaskChk').checked = l.clipped;
    }
    function setLayerProp(prop, val) { if(layers[activeIdx]) { layers[activeIdx][prop] = val; if(prop==='blendMode') layers[activeIdx].canvas.style.mixBlendMode = val; } }
    function deleteLayer() { if(layers.length <= 1) return clearLayer(); layers[activeIdx].canvas.remove(); layers.splice(activeIdx, 1); setActiveLayer(Math.max(0, activeIdx - 1)); }
    function clearLayer() { saveHistory(); layers[activeIdx].ctx.clearRect(0,0, CONFIG.w, CONFIG.h); }
    function renderLayerUI() {
        const list = document.getElementById('layerList'); list.innerHTML = '';
        layers.forEach((l, i) => {
            const el = document.createElement('div'); el.className = `l-item ${i === activeIdx ? 'active' : ''}`;
            el.innerHTML = `<span class="l-vis ${l.visible?'on':''}"></span> ${l.clipped ? "↳ " : ""}${l.name}`;
            el.onclick = () => setActiveLayer(i); list.appendChild(el);
        });
    }
    function saveHistory() {
        if(layers.length === 0) return; redoStack = []; 
        if (historyStack.length >= MAX_HISTORY) historyStack.shift();
        const dpr = window.devicePixelRatio || 1;
        historyStack.push({ layerId: layers[activeIdx].id, data: layers[activeIdx].ctx.getImageData(0, 0, CONFIG.w * dpr, CONFIG.h * dpr) });
    }
    function undo() {
        if (historyStack.length === 0) return;
        const cur = layers[activeIdx]; 
        const dpr = window.devicePixelRatio || 1;
        redoStack.push({ layerId: cur.id, data: cur.ctx.getImageData(0, 0, CONFIG.w * dpr, CONFIG.h * dpr) });
        const last = historyStack.pop(); const l = layers.find(l => l.id === last.layerId); if(l) l.ctx.putImageData(last.data, 0, 0);
    }
    function redo() {
        if (redoStack.length === 0) return;
        const cur = layers[activeIdx]; 
        const dpr = window.devicePixelRatio || 1;
        historyStack.push({ layerId: cur.id, data: cur.ctx.getImageData(0, 0, CONFIG.w * dpr, CONFIG.h * dpr) });
        const next = redoStack.pop(); const l = layers.find(l => l.id === next.layerId); if(l) l.ctx.putImageData(next.data, 0, 0);
    }
    function saveImage() {
        const canvas = document.createElement('canvas'); canvas.width = CONFIG.w; canvas.height = CONFIG.h;
        const ctx = canvas.getContext('2d');
        layers.forEach(l => { if(l.visible) ctx.drawImage(l.canvas, 0, 0, CONFIG.w, CONFIG.h); });
        const link = document.createElement('a'); link.download = 'art.png'; link.href = canvas.toDataURL(); link.click();
    }

    function setTool(t) { 
        if(t==='lasso' && state.tool==='lasso') { state.selectionPath = null; state.lassoPoly = []; return; }
        state.tool = t; updateUI(); 
        const mh = document.getElementById('mixer-hint'); mh.style.display = t==='mixer' ? 'block' : 'none';
        document.getElementById('brush-controls').style.display = (t==='brush' || t==='eraser' || t==='blend' || t==='mixer') ? 'block' : 'none';
        document.getElementById('grad-controls').style.display = t==='gradient' ? 'block' : 'none';
        document.getElementById('lasso-controls').style.display = t==='lasso' ? 'block' : 'none';
        state.lassoPoly = [];
    }
    function setLassoMode(m) { state.lassoMode = m; state.lassoPoly = []; updateUIButtons('#lasso-controls .btn'); }
    function setBrush(b) { state.brush = b; updateUIButtons('#brush-controls .btn-grid .btn'); updateCursorUI(); }
    function updateUIButtons(sel) { document.querySelectorAll(sel).forEach(b => b.classList.remove('active')); event.target.classList.add('active'); }
    function updateUI() { 
        document.querySelectorAll('.t-btn').forEach(b => b.classList.remove('active', 'blend-active', 'grad-active', 'mixer-active')); 
        const map = {'brush':'t-paint', 'blend':'t-blend', 'gradient':'t-grad', 'lasso':'t-lasso', 'eraser':'t-erase', 'mixer':'t-mixer'};
        const el = document.getElementById(map[state.tool]); 
        if(el) { if(state.tool==='blend') el.classList.add('blend-active'); else if(state.tool==='gradient') el.classList.add('grad-active'); else if(state.tool==='mixer') el.classList.add('mixer-active'); else el.classList.add('active'); }
    }
    
    function updateCursorUI(pos, altDown) {
        if(pos) { 
            cursor.style.left = pos.x+'px'; 
            cursor.style.top = pos.y+'px'; 
        }
        
        const isMixerSample = state.tool === 'mixer' && altDown;
        const isSpecial = state.tool === 'gradient' || state.tool === 'picker' || state.tool === 'lasso';
        
        let s = isMixerSample || isSpecial ? 20 : (state.size * (state.usePressure ? state.pressure : 1)) * view.scale;
        
        cursor.style.width = s+'px'; cursor.style.height = s+'px';
        cursor.style.borderRadius = (state.tool === 'lasso' || (state.brush!=='round' && state.brush!=='air_soft' && !isSpecial)) ? '0' : '50%';
        cursor.style.border = isMixerSample ? '2px dashed #e1b12c' : (state.tool === 'lasso' ? '2px solid #00a8ff' : '2px solid white');
        cursor.style.transform = state.tool === 'lasso' ? 'translate(-50%, -50%) rotate(45deg)' : 'translate(-50%, -50%)';
    }

    function pickColorUI(p) {
        const c = pickColorAt(layers[activeIdx].ctx, p.x, p.y);
        if(c) {
            state.color = "#" + ((1 << 24) + (c.r << 16) + (c.g << 8) + c.b).toString(16).slice(1);
            updateSlidersFromColor(state.color);
        }
    }

    document.getElementById('sl-r').oninput = updateColorFromSliders;
    document.getElementById('sl-g').oninput = updateColorFromSliders;
    document.getElementById('sl-b').oninput = updateColorFromSliders;
    document.getElementById('sl-size').oninput = e => { state.size = +e.target.value; document.getElementById('val-size').innerText = state.size; updateCursorUI(); };
    document.getElementById('sl-mix').oninput = e => { state.mix = +e.target.value / 100; document.getElementById('val-mix').innerText = e.target.value; };
    document.getElementById('sl-jitter').oninput = e => { state.jitter = +e.target.value; document.getElementById('val-jitter').innerText = state.jitter; };
    document.getElementById('gradStart').oninput = e => state.gradStartColor = e.target.value;
    document.getElementById('gradEnd').oninput = e => state.gradEndColor = e.target.value;
    document.getElementById('gradStartAlpha').oninput = e => state.gradStartOpacity = +e.target.value / 100;
    document.getElementById('gradEndAlpha').oninput = e => state.gradEndOpacity = +e.target.value / 100;

</script>
</body>
</html>